using AlgoTrendy.Common.Abstractions.Brokers;
using AlgoTrendy.Common.Abstractions.Factories;
using AlgoTrendy.Common.Abstractions.Mappers;
using AlgoTrendy.Common.Abstractions.Utilities;
using AlgoTrendy.Core.Enums;
using AlgoTrendy.Core.Models;
using Binance.Net.Clients;
using Binance.Net.Enums;
using Binance.Net.Objects;
using CryptoExchange.Net.Authentication;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;

namespace AlgoTrendy.TradingEngine.Brokers;

/// <summary>
/// REFACTORED Binance broker implementation using new base class architecture.
/// COMPARISON:
///   - BinanceBroker.cs: 555 lines with duplicate code
///   - BinanceBrokerV2.cs: ~350 lines (37% reduction)
///   - Eliminates: Rate limiting, connection validation, error handling, logging patterns
///   - Uses: BrokerBase, RateLimiter, OrderFactoryExtensions, BrokerMappers
///
/// BENCHMARK THIS vs BinanceBroker.cs for performance comparison!
/// </summary>
public class BinanceBrokerV2 : BrokerBase
{
    private readonly BinanceRestClient _client;
    private readonly BinanceOptions _options;

    public override string BrokerName => "binance";

    public BinanceBrokerV2(
        IOptions<BinanceOptions> options,
        ILogger<BinanceBrokerV2> logger)
        : base(logger, RateLimiterPresets.CreateBinanceRateLimiter())
    {
        _options = options?.Value ?? throw new ArgumentNullException(nameof(options));

        // Configure environment for Binance US if enabled
        if (_options.UseBinanceUS)
        {
            Environment.SetEnvironmentVariable("BINANCE_US_API", "true");
            Logger.LogInformation("Binance broker configured for BINANCE US");
        }

        // Configure testnet environment
        if (_options.UseTestnet)
        {
            Environment.SetEnvironmentVariable("BINANCE_API_TESTNET", "true");
            Logger.LogInformation("Binance broker configured for TESTNET");
        }
        else
        {
            Logger.LogInformation("Binance broker configured for PRODUCTION");
        }

        // Initialize Binance REST client
        _client = new BinanceRestClient(opts =>
        {
            opts.ApiCredentials = new ApiCredentials(_options.ApiKey, _options.ApiSecret);
        });
    }

    #region Connection Management (Uses BrokerBase)

    protected override async Task<bool> ConnectInternalAsync(CancellationToken cancellationToken)
    {
        // Test connection by getting account info
        var accountInfoResult = await _client.SpotApi.Account.GetAccountInfoAsync(ct: cancellationToken);

        if (!accountInfoResult.Success)
        {
            Logger.LogError("Failed to connect to Binance: {Error}", accountInfoResult.Error?.Message);
            return false;
        }

        Logger.LogInformation(
            "Connected to Binance successfully. Account Type: {AccountType}, Can Trade: {CanTrade}",
            accountInfoResult.Data.AccountType,
            accountInfoResult.Data.CanTrade);

        return true;
    }

    protected override Task DisconnectInternalAsync(CancellationToken cancellationToken)
    {
        // Binance REST client doesn't require explicit disconnection
        return Task.CompletedTask;
    }

    #endregion

    #region Order Management

    public override async Task<Order> PlaceOrderAsync(OrderRequest request, CancellationToken cancellationToken = default)
    {
        EnsureConnected();
        ValidateSymbol(request.Symbol);

        // Rate limiting handled by BrokerBase
        await EnforceRateLimitAsync(request.Symbol, cancellationToken);

        try
        {
            LogOperationStart("PlaceOrder", request.Symbol);

            // Map order parameters using BrokerMappers
            var orderSide = MapOrderSide(request.Side);
            var orderType = MapOrderType(request.Type);

            // Place order based on type
            var result = request.Type switch
            {
                OrderType.Market => await _client.SpotApi.Trading.PlaceOrderAsync(
                    symbol: request.Symbol,
                    side: orderSide,
                    type: SpotOrderType.Market,
                    quantity: request.Quantity,
                    ct: cancellationToken),

                OrderType.Limit => await _client.SpotApi.Trading.PlaceOrderAsync(
                    symbol: request.Symbol,
                    side: orderSide,
                    type: SpotOrderType.Limit,
                    quantity: request.Quantity,
                    price: request.Price,
                    timeInForce: TimeInForce.GoodTillCanceled,
                    ct: cancellationToken),

                OrderType.StopLoss => await _client.SpotApi.Trading.PlaceOrderAsync(
                    symbol: request.Symbol,
                    side: orderSide,
                    type: SpotOrderType.StopLoss,
                    quantity: request.Quantity,
                    stopPrice: request.StopPrice,
                    ct: cancellationToken),

                _ => throw new NotSupportedException($"Order type {request.Type} not supported")
            };

            if (!result.Success)
            {
                throw new InvalidOperationException($"Failed to place order: {result.Error?.Message}");
            }

            // Convert to Order model using OrderFactoryExtensions
            var order = MapBinanceOrderToOrder(result.Data, request);

            LogOperationSuccess("PlaceOrder", request.Symbol, $"ExchangeOrderId: {order.ExchangeOrderId}");

            return order;
        }
        catch (Exception ex)
        {
            LogOperationError(ex, "PlaceOrder", request.Symbol);
            throw;
        }
    }

    public override async Task<Order> CancelOrderAsync(string orderId, string symbol, CancellationToken cancellationToken = default)
    {
        EnsureConnected();
        ValidateOrderId(orderId);
        ValidateSymbol(symbol);

        try
        {
            LogOperationStart("CancelOrder", symbol);

            var result = await _client.SpotApi.Trading.CancelOrderAsync(
                symbol: symbol,
                orderId: long.Parse(orderId),
                ct: cancellationToken);

            if (!result.Success)
            {
                throw new InvalidOperationException($"Failed to cancel order: {result.Error?.Message}");
            }

            // Use OrderFactoryExtensions to create cancelled order placeholder
            var order = OrderFactoryExtensions.CreateCancelledOrderPlaceholder(
                orderId: orderId,
                clientOrderId: result.Data?.ClientOrderId,
                symbol: symbol,
                exchange: BrokerName);

            LogOperationSuccess("CancelOrder", symbol, $"OrderId: {orderId}");

            return order;
        }
        catch (Exception ex)
        {
            LogOperationError(ex, "CancelOrder", symbol);
            throw;
        }
    }

    public override async Task<Order> GetOrderStatusAsync(string orderId, string symbol, CancellationToken cancellationToken = default)
    {
        EnsureConnected();
        ValidateOrderId(orderId);
        ValidateSymbol(symbol);

        try
        {
            var result = await _client.SpotApi.Trading.GetOrderAsync(
                symbol: symbol,
                orderId: long.Parse(orderId),
                ct: cancellationToken);

            if (!result.Success)
            {
                throw new InvalidOperationException($"Order {orderId} not found for symbol {symbol}");
            }

            return MapBinanceOrderToOrder(result.Data, null);
        }
        catch (Exception ex)
        {
            LogOperationError(ex, "GetOrderStatus", symbol);
            throw;
        }
    }

    public override async Task<List<Order>> GetOpenOrdersAsync(string? symbol = null, CancellationToken cancellationToken = default)
    {
        EnsureConnected();

        try
        {
            var result = string.IsNullOrEmpty(symbol)
                ? await _client.SpotApi.Trading.GetOpenOrdersAsync(ct: cancellationToken)
                : await _client.SpotApi.Trading.GetOpenOrdersAsync(symbol: symbol, ct: cancellationToken);

            if (!result.Success)
            {
                throw new InvalidOperationException($"Failed to get open orders: {result.Error?.Message}");
            }

            return result.Data.Select(binanceOrder => MapBinanceOrderToOrder(binanceOrder, null)).ToList();
        }
        catch (Exception ex)
        {
            LogOperationError(ex, "GetOpenOrders", symbol ?? "all");
            throw;
        }
    }

    public override async Task<List<Position>> GetPositionsAsync(CancellationToken cancellationToken = default)
    {
        // Spot trading doesn't have positions in the traditional sense
        return await Task.FromResult(new List<Position>());
    }

    public override async Task<Balance> GetBalanceAsync(CancellationToken cancellationToken = default)
    {
        EnsureConnected();

        try
        {
            var accountInfoResult = await _client.SpotApi.Account.GetAccountInfoAsync(ct: cancellationToken);

            if (!accountInfoResult.Success)
            {
                throw new InvalidOperationException($"Failed to get balance: {accountInfoResult.Error?.Message}");
            }

            var usdtBalance = accountInfoResult.Data.Balances.FirstOrDefault(b => b.Asset == "USDT");

            return new Balance
            {
                Currency = "USDT",
                Available = usdtBalance?.Available ?? 0,
                Total = (usdtBalance?.Available ?? 0) + (usdtBalance?.Locked ?? 0),
                Exchange = BrokerName
            };
        }
        catch (Exception ex)
        {
            LogOperationError(ex, "GetBalance", "USDT");
            throw;
        }
    }

    #endregion

    #region Mapping Helpers (Uses BrokerMappers)

    private static OrderSide MapOrderSide(Binance.Net.Enums.OrderSide binanceSide)
    {
        return binanceSide switch
        {
            Binance.Net.Enums.OrderSide.Buy => OrderSide.Buy,
            Binance.Net.Enums.OrderSide.Sell => OrderSide.Sell,
            _ => throw new ArgumentException($"Unsupported Binance order side: {binanceSide}")
        };
    }

    private static Binance.Net.Enums.OrderSide MapOrderSide(OrderSide side)
    {
        return side switch
        {
            OrderSide.Buy => Binance.Net.Enums.OrderSide.Buy,
            OrderSide.Sell => Binance.Net.Enums.OrderSide.Sell,
            _ => throw new ArgumentException($"Unsupported order side: {side}")
        };
    }

    private static SpotOrderType MapOrderType(OrderType type)
    {
        return type switch
        {
            OrderType.Market => SpotOrderType.Market,
            OrderType.Limit => SpotOrderType.Limit,
            OrderType.StopLoss => SpotOrderType.StopLoss,
            OrderType.StopLossLimit => SpotOrderType.StopLossLimit,
            OrderType.TakeProfit => SpotOrderType.TakeProfit,
            OrderType.TakeProfitLimit => SpotOrderType.TakeProfitLimit,
            _ => throw new ArgumentException($"Unsupported order type: {type}")
        };
    }

    private static OrderStatus MapOrderStatus(Binance.Net.Enums.OrderStatus binanceStatus)
    {
        return binanceStatus switch
        {
            Binance.Net.Enums.OrderStatus.New => OrderStatus.Pending,
            Binance.Net.Enums.OrderStatus.PartiallyFilled => OrderStatus.PartiallyFilled,
            Binance.Net.Enums.OrderStatus.Filled => OrderStatus.Filled,
            Binance.Net.Enums.OrderStatus.Canceled => OrderStatus.Cancelled,
            Binance.Net.Enums.OrderStatus.Rejected => OrderStatus.Rejected,
            Binance.Net.Enums.OrderStatus.Expired => OrderStatus.Expired,
            _ => OrderStatus.Pending
        };
    }

    private Order MapBinanceOrderToOrder(Binance.Net.Objects.Models.Spot.BinanceOrder binanceOrder, OrderRequest? originalRequest)
    {
        return new Order
        {
            OrderId = Guid.NewGuid().ToString(),
            ClientOrderId = OrderFactory.GenerateClientOrderId(),
            ExchangeOrderId = binanceOrder.Id.ToString(),
            Symbol = binanceOrder.Symbol,
            Exchange = BrokerName,
            Side = MapOrderSide(binanceOrder.Side),
            Type = originalRequest?.Type ?? OrderType.Limit, // Fallback if not provided
            Status = MapOrderStatus(binanceOrder.Status),
            Quantity = binanceOrder.Quantity,
            FilledQuantity = binanceOrder.QuantityFilled,
            Price = originalRequest?.Price ?? binanceOrder.Price,
            StopPrice = originalRequest?.StopPrice,
            AveragePrice = binanceOrder.QuoteQuantityFilled > 0
                ? binanceOrder.QuoteQuantityFilled / binanceOrder.QuantityFilled
                : null,
            StrategyId = originalRequest?.StrategyId,
            CreatedAt = DateTime.UtcNow,
            UpdatedAt = DateTime.UtcNow,
            SubmittedAt = DateTime.UtcNow,
            Metadata = originalRequest?.Metadata
        };
    }

    #endregion

    #region Disposal

    protected override void Dispose(bool disposing)
    {
        if (disposing && !Disposed)
        {
            _client?.Dispose();
        }

        base.Dispose(disposing);
    }

    #endregion
}
