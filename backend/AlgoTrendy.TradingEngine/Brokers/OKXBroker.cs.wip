using AlgoTrendy.Core.Enums;
using AlgoTrendy.Core.Interfaces;
using AlgoTrendy.Core.Models;
using CryptoExchange.Net.Authentication;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using OKX.Net.Clients;
using OKX.Net.Enums;
using OKX.Net.Objects;

namespace AlgoTrendy.TradingEngine.Brokers;

/// <summary>
/// OKX broker implementation for cryptocurrency trading
/// Supports: Spot, Margin, Futures, Perpetual, Options
/// </summary>
public class OKXBroker : IBroker
{
    private OKXRestClient? _client;
    private readonly OKXOptions _options;
    private readonly ILogger<OKXBroker> _logger;
    private bool _isConnected = false;

    // Rate limiting (OKX: 20 requests/2 seconds = 10 requests/second)
    private readonly SemaphoreSlim _rateLimiter = new(10, 10);
    private readonly Dictionary<string, DateTime> _lastRequestTime = new();
    private readonly object _requestTimeLock = new();
    private const int MinRequestIntervalMs = 100; // ~10 requests/second

    public string BrokerName => "okx";

    public OKXBroker(
        IOptions<OKXOptions> options,
        ILogger<OKXBroker> logger)
    {
        _options = options?.Value ?? throw new ArgumentNullException(nameof(options));
        _logger = logger ?? throw new ArgumentNullException(nameof(logger));
    }

    /// <summary>
    /// Gets or initializes the OKX REST client (lazy initialization)
    /// </summary>
    private OKXRestClient GetClient()
    {
        if (_client == null)
        {
            _client = new OKXRestClient(opts =>
            {
                opts.ApiCredentials = new OKXApiCredentials(
                    _options.ApiKey,
                    _options.ApiSecret,
                    _options.Passphrase);

                // Set to demo trading if enabled
                if (_options.UseDemoTrading)
                {
                    opts.Environment = OKXApiEnvironment.Demo;
                    _logger.LogInformation("OKX client configured for DEMO trading");
                }
                else
                {
                    _logger.LogInformation("OKX client configured for LIVE trading");
                }
            });
        }
        return _client;
    }

    /// <summary>
    /// Connects to OKX API and verifies credentials
    /// </summary>
    public async Task<bool> ConnectAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("Connecting to OKX ({Environment})...",
                _options.UseDemoTrading ? "Demo" : "Live");

            // Test connection by getting account balance
            var balanceResult = await GetClient().UnifiedApi.Account.GetAccountBalanceAsync(ct: cancellationToken);

            if (!balanceResult.Success)
            {
                _logger.LogError("Failed to connect to OKX: {Error}", balanceResult.Error?.Message);
                return false;
            }

            _isConnected = true;
            _logger.LogInformation(
                "Connected to OKX successfully. Account has {AssetCount} assets",
                balanceResult.Data.FirstOrDefault()?.Assets?.Count() ?? 0);

            return true;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to connect to OKX");
            return false;
        }
    }

    /// <summary>
    /// Gets current balance in the specified currency
    /// </summary>
    public async Task<decimal> GetBalanceAsync(string currency = "USDT", CancellationToken cancellationToken = default)
    {
        await EnsureConnectedAsync();
        await RateLimitAsync("GetBalance");

        try
        {
            var balanceResult = await GetClient().UnifiedApi.Account.GetAccountBalanceAsync(ct: cancellationToken);

            if (!balanceResult.Success)
            {
                _logger.LogWarning("Failed to get balance: {Error}", balanceResult.Error?.Message);
                return 0m;
            }

            var balance = balanceResult.Data
                .FirstOrDefault()?.Assets
                ?.FirstOrDefault(a => a.Asset == currency);

            return balance?.AvailableBalance ?? 0m;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get balance for {Currency}", currency);
            return 0m;
        }
    }

    /// <summary>
    /// Gets all current positions
    /// </summary>
    public async Task<IEnumerable<Position>> GetPositionsAsync(CancellationToken cancellationToken = default)
    {
        await EnsureConnectedAsync();
        await RateLimitAsync("GetPositions");

        try
        {
            var positionsResult = await GetClient().UnifiedApi.Account.GetPositionsAsync(ct: cancellationToken);

            if (!positionsResult.Success)
            {
                _logger.LogWarning("Failed to get positions: {Error}", positionsResult.Error?.Message);
                return Array.Empty<Position>();
            }

            var positions = new List<Position>();

            foreach (var pos in positionsResult.Data)
            {
                if (pos.Quantity == 0) continue; // Skip closed positions

                positions.Add(new Position
                {
                    PositionId = pos.Symbol,
                    Symbol = pos.Symbol,
                    Exchange = BrokerName,
                    Side = pos.PositionSide == PositionSide.Long ? Core.Enums.OrderSide.Buy : Core.Enums.OrderSide.Sell,
                    Quantity = Math.Abs(pos.Quantity),
                    EntryPrice = pos.AveragePrice,
                    CurrentPrice = pos.MarkPrice ?? pos.AveragePrice,
                    Leverage = pos.Leverage,
                    MarginType = Core.Enums.MarginType.Cross,
                    LiquidationPrice = pos.LiquidationPrice,
                    OpenedAt = DateTime.UtcNow
                });
            }

            return positions;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get positions");
            return Array.Empty<Position>();
        }
    }

    /// <summary>
    /// Places a new order
    /// </summary>
    public async Task<Order> PlaceOrderAsync(OrderRequest request, CancellationToken cancellationToken = default)
    {
        await EnsureConnectedAsync();
        await RateLimitAsync($"PlaceOrder_{request.Symbol}");

        try
        {
            _logger.LogInformation(
                "Placing {OrderType} {Side} order: {Symbol} x {Quantity}",
                request.Type, request.Side, request.Symbol, request.Quantity);

            var side = request.Side == Core.Enums.OrderSide.Buy ? OrderSide.Buy : OrderSide.Sell;
            var orderType = request.Type == Core.Enums.OrderType.Market ? OKX.Net.Enums.OrderType.MarketOrder : OKX.Net.Enums.OrderType.LimitOrder;

            var orderResult = await GetClient().UnifiedApi.Trading.PlaceOrderAsync(
                symbol: request.Symbol,
                side: side,
                type: orderType,
                quantity: request.Quantity,
                price: request.Price,
                positionSide: PositionSide.Net, // Use net mode (not hedge mode)
                tradeMode: TradeMode.Cash,  // Cash/Spot trading
                ct: cancellationToken);

            if (!orderResult.Success)
            {
                _logger.LogError("Failed to place order: {Error}", orderResult.Error?.Message);
                throw new InvalidOperationException($"Order placement failed: {orderResult.Error?.Message}");
            }

            _logger.LogInformation("Order placed successfully: {OrderId}", orderResult.Data.OrderId);

            return new Order
            {
                OrderId = orderResult.Data.OrderId,
                ClientOrderId = request.ClientOrderId ?? orderResult.Data.OrderId,
                Symbol = request.Symbol,
                Exchange = BrokerName,
                Side = request.Side,
                Type = request.Type,
                Quantity = request.Quantity,
                Price = request.Price,
                Status = Core.Enums.OrderStatus.Pending,
                FilledQuantity = 0m,
                CreatedAt = DateTime.UtcNow
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to place order for {Symbol}", request.Symbol);
            throw;
        }
    }

    /// <summary>
    /// Cancels an existing order
    /// </summary>
    public async Task<Order> CancelOrderAsync(string orderId, string symbol, CancellationToken cancellationToken = default)
    {
        await EnsureConnectedAsync();
        await RateLimitAsync($"CancelOrder_{symbol}");

        try
        {
            var cancelResult = await GetClient().UnifiedApi.Trading.CancelOrderAsync(
                symbol: symbol,
                orderId: orderId,
                ct: cancellationToken);

            if (!cancelResult.Success)
            {
                _logger.LogError("Failed to cancel order {OrderId}: {Error}",
                    orderId, cancelResult.Error?.Message);
                throw new InvalidOperationException($"Order cancellation failed: {cancelResult.Error?.Message}");
            }

            _logger.LogInformation("Order {OrderId} cancelled successfully", orderId);

            return new Order
            {
                OrderId = orderId,
                ClientOrderId = orderId,
                Symbol = symbol,
                Exchange = BrokerName,
                Side = Core.Enums.OrderSide.Buy, // Unknown, using default
                Type = Core.Enums.OrderType.Limit, // Unknown, using default
                Quantity = 0m,
                Status = Core.Enums.OrderStatus.Cancelled,
                FilledQuantity = 0m,
                CreatedAt = DateTime.UtcNow,
                UpdatedAt = DateTime.UtcNow
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to cancel order {OrderId}", orderId);
            throw;
        }
    }

    /// <summary>
    /// Gets the status of an existing order
    /// </summary>
    public async Task<Order> GetOrderStatusAsync(string orderId, string symbol, CancellationToken cancellationToken = default)
    {
        await EnsureConnectedAsync();
        await RateLimitAsync($"GetOrderStatus_{symbol}");

        try
        {
            var orderResult = await GetClient().UnifiedApi.Trading.GetOrderAsync(
                symbol: symbol,
                orderId: orderId,
                ct: cancellationToken);

            if (!orderResult.Success)
            {
                _logger.LogError("Failed to get order status for {OrderId}: {Error}",
                    orderId, orderResult.Error?.Message);
                throw new InvalidOperationException($"Get order status failed: {orderResult.Error?.Message}");
            }

            var okxOrder = orderResult.Data;

            return new Order
            {
                OrderId = okxOrder.OrderId,
                ClientOrderId = okxOrder.ClientOrderId ?? string.Empty,
                Symbol = okxOrder.Symbol,
                Exchange = BrokerName,
                Side = okxOrder.Side == OrderSide.Buy ? Core.Enums.OrderSide.Buy : Core.Enums.OrderSide.Sell,
                Type = MapOKXOrderType(okxOrder.Type),
                Quantity = okxOrder.Quantity,
                Price = okxOrder.Price,
                FilledQuantity = okxOrder.QuantityFilled ?? 0m,
                AverageFillPrice = okxOrder.AveragePrice,
                Status = MapOKXOrderStatus(okxOrder.State),
                CreatedAt = okxOrder.CreateTime,
                UpdatedAt = okxOrder.UpdateTime
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get order status for {OrderId}", orderId);
            throw;
        }
    }

    /// <summary>
    /// Gets the current market price for a symbol
    /// </summary>
    public async Task<decimal> GetCurrentPriceAsync(string symbol, CancellationToken cancellationToken = default)
    {
        await EnsureConnectedAsync();
        await RateLimitAsync($"GetPrice_{symbol}");

        try
        {
            var tickerResult = await GetClient().UnifiedApi.ExchangeData.GetTickerAsync(symbol, ct: cancellationToken);

            if (!tickerResult.Success)
            {
                _logger.LogError("Failed to get price for {Symbol}: {Error}",
                    symbol, tickerResult.Error?.Message);
                return 0m;
            }

            return tickerResult.Data.LastPrice ?? 0m;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Failed to get current price for {Symbol}", symbol);
            return 0m;
        }
    }

    /// <summary>
    /// Sets leverage for a symbol
    /// </summary>
    public async Task<bool> SetLeverageAsync(
        string symbol,
        decimal leverage,
        MarginType marginType = MarginType.Cross,
        CancellationToken cancellationToken = default)
    {
        await EnsureConnectedAsync();

        try
        {
            _logger.LogInformation("Setting leverage for {Symbol} to {Leverage}x ({MarginType})",
                symbol, leverage, marginType);

            // OKX leverage management via UnifiedApi.Account.SetLeverageAsync
            // Note: OKX.Net API may vary - this is a placeholder implementation
            // Check OKX.Net documentation for exact method signature
            _logger.LogWarning("OKX leverage management requires specific OKX.Net API implementation");

            return await Task.FromResult(true);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error setting leverage for {Symbol}", symbol);
            return false;
        }
    }

    /// <summary>
    /// Gets current leverage information for a symbol
    /// </summary>
    public async Task<LeverageInfo> GetLeverageInfoAsync(string symbol, CancellationToken cancellationToken = default)
    {
        await EnsureConnectedAsync();

        try
        {
            var positions = await GetPositionsAsync(cancellationToken);
            var position = positions.FirstOrDefault(p => p.Symbol == symbol);

            if (position == null)
            {
                // No position, return default leverage info
                return new LeverageInfo
                {
                    Symbol = symbol,
                    CurrentLeverage = 1,
                    MaxLeverage = 125, // OKX default max for perpetuals
                    MarginType = MarginType.Cross,
                    CollateralAmount = 0,
                    BorrowedAmount = 0
                };
            }

            return new LeverageInfo
            {
                Symbol = symbol,
                CurrentLeverage = position.Leverage,
                MaxLeverage = 125,
                MarginType = position.MarginType ?? MarginType.Cross,
                LiquidationPrice = position.LiquidationPrice,
                CollateralAmount = position.CollateralAmount ?? 0,
                BorrowedAmount = position.BorrowedAmount ?? 0
            };
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting leverage info for {Symbol}", symbol);
            throw;
        }
    }

    /// <summary>
    /// Gets margin health ratio (available balance / maintenance margin)
    /// </summary>
    public async Task<decimal> GetMarginHealthRatioAsync(CancellationToken cancellationToken = default)
    {
        await EnsureConnectedAsync();

        try
        {
            var balanceResult = await GetClient().UnifiedApi.Account.GetAccountBalanceAsync(ct: cancellationToken);

            if (!balanceResult.Success || !balanceResult.Data.Any())
            {
                _logger.LogError("Failed to get account balance: {Error}", balanceResult.Error?.Message);
                throw new InvalidOperationException($"Failed to get account balance: {balanceResult.Error?.Message}");
            }

            var account = balanceResult.Data.First();
            var totalEquity = account.TotalEquity ?? 0;
            var totalMargin = account.MaintenanceMargin ?? 0;

            if (totalEquity == 0)
            {
                return 1.0m; // No positions, healthy
            }

            // Health ratio: higher is healthier (available balance / margin requirement)
            // OKX: healthy > 1.0, warning < 0.5, liquidation at ~0
            var healthRatio = totalMargin > 0 ? totalEquity / totalMargin : 1.0m;

            _logger.LogDebug("Margin health ratio: {Ratio} (Equity: {Equity}, Margin: {Margin})",
                healthRatio, totalEquity, totalMargin);

            return healthRatio;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Error getting margin health ratio");
            throw;
        }
    }

    // Helper methods

    private async Task EnsureConnectedAsync()
    {
        if (!_isConnected)
        {
            await ConnectAsync();
        }
    }

    private async Task RateLimitAsync(string operation)
    {
        await _rateLimiter.WaitAsync();
        try
        {
            lock (_requestTimeLock)
            {
                if (_lastRequestTime.TryGetValue(operation, out var lastTime))
                {
                    var elapsed = (DateTime.UtcNow - lastTime).TotalMilliseconds;
                    if (elapsed < MinRequestIntervalMs)
                    {
                        var delay = MinRequestIntervalMs - (int)elapsed;
                        Task.Delay(delay).Wait();
                    }
                }
                _lastRequestTime[operation] = DateTime.UtcNow;
            }
        }
        finally
        {
            _rateLimiter.Release();
        }
    }

    private OrderType MapOKXOrderType(OKX.Net.Enums.OrderType okxType)
    {
        return okxType switch
        {
            OKX.Net.Enums.OrderType.MarketOrder => OrderType.Market,
            OKX.Net.Enums.OrderType.LimitOrder => OrderType.Limit,
            OKX.Net.Enums.OrderType.PostOnly => OrderType.Limit,
            _ => OrderType.Market
        };
    }

    private OrderStatus MapOKXOrderStatus(OKX.Net.Enums.OrderStatus okxStatus)
    {
        return okxStatus switch
        {
            OKX.Net.Enums.OrderStatus.Live => OrderStatus.Open,
            OKX.Net.Enums.OrderStatus.PartiallyFilled => OrderStatus.PartiallyFilled,
            OKX.Net.Enums.OrderStatus.Filled => OrderStatus.Filled,
            OKX.Net.Enums.OrderStatus.Canceled => OrderStatus.Cancelled,
            _ => OrderStatus.Open
        };
    }

    public void Dispose()
    {
        _client?.Dispose();
        _rateLimiter?.Dispose();
    }
}

/// <summary>
/// Configuration options for OKX broker
/// </summary>
public class OKXOptions
{
    public string ApiKey { get; set; } = string.Empty;
    public string ApiSecret { get; set; } = string.Empty;
    public string Passphrase { get; set; } = string.Empty;
    public bool UseDemoTrading { get; set; } = true; // Default to demo trading
}
